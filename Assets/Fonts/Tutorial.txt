Welcome to Pipeline Bakery!
Our job is to feed the very hungry processor.
He likes instructions.
To make the processor happy, we have to feed him instruction sets without hazards.
Let's start simple.
An arithmetic instruction has five parts:
Fetch (FETCH), the initial memory read.
Decode (DEC), where the processor selects what register to operate on.
Execute (EXE), where the processor's arithmetic logic unit performs mathematical operations.
Memory write (MEM), where the memory is written to after operations.
Write back (WB),  where the processor writes the result to a register after operations.
We create sequences of instructions to feed to the processor.
We assemble the instruction in an order called "pipelining."
We start by feeding the processor the first part of the first instruction.
Then, we feed him the second part of the first instruction AND the first part of the...
...second instruction. But there's a problem. See this instruction sequence?
In instruction #2, we do math in the register $t0.
But, if it's the same register we read from in the DEC step of instruction #3...
we get a hazard.
This is called a data hazard.
We try to use data from a register that doesn't have the correct value yet.
To fix this, we use a technique called data forwarding.
Tap each stage to forward the data from...
...the EXE stage of instruction #2 to the EXE stage of instruction #3.